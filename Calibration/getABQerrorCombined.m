function [combinedError, errRatio, varargout] = ...
                 getABQerrorCombined(newparams, tests, testnums, errortype)
% This is the Objective Function for applying optimization techniques
%
% newparams = vector of material hardening parameters
% tests     = specifically designed .mat struct file containing test data
%             (see documentation)
% testnums  = subset of tests on which to run analysis
% errortype = selector for internal error designation (see documentation or
%             calcResidualError.m)


%
% Recover Parameters from newparams ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%

%newparams(1) = Fy
%newparams(2) = total hardening
%newparams(3) = C0 (linear kinematic term)
%newparams(4) = b (isotropic rate term)
%newparams(5,7,...) = gamman (nth kinematic rate)
%newparams(6,8,...) = fraction saturated hardening per ksi backstress

Fy = newparams(1);
C0 = newparams(3);
b  = newparams(4);

totalksi=0;
for n = 1:( (length(newparams) - 4)/2 )
    gamman(n) = newparams(2*n+3); %#ok<*AGROW>
    Cn(n) = newparams(2) * newparams(2*n+4) * gamman(n);
    totalksi = totalksi + newparams(2) * newparams(2*n+4);
    
end
Qinf = newparams(2) - totalksi;


params = [Fy Qinf b C0 0 reshape([Cn;gamman],length(Cn)*2,1)'];

%
% rudimentary check on parameters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%

% get all field names of the .mat struct
testnames = fieldnames(tests);

% check the requested inputs...
if nargin < 3
    % run all tests if not otherwise specified
    testnums = 1:length(testnames);
    % default to error type 4 if not otherwise specified
    errortype = 4;
end

% obtain the relevant test names
testnames = testnames(testnums);

% preallocate fracture mechanics output (necessary if any params < 0)
nanvec    = NaN * ones(1,length(testnums));
PEEQfinal = nanvec;
Tfinal    = nanvec;
Xfinal    = nanvec;
SMCSfinal = nanvec;
CVGMfinal = nanvec;

if any( params < 0 )
    % if any parameters are less than zero, return nothing
    combinedError = 1;
    errRatio = 1;
    varargout{1} = PEEQfinal;
    varargout{2} = Tfinal;
    varargout{3} = Xfinal;
    varargout{4} = SMCSfinal;
    varargout{5} = CVGMfinal;

    disp('Out of bounds')
    return;
end

%
% calculate the combined error ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%

% display information for user
fprintf('Writing INP Histories...');

% using a template input file, insert our own *Static and *Amplitude
% keyword settings, based on test displacement peaks (hist)
for i = 1:length(testnames)
    % addHistINPfile(template, target, testdata)
    writeHistINPfile( tests.(testnames{i}).template, [testnames{i} '.inp'], ...
                    tests.(testnames{i}) );
end
fprintf(' Done!\n');

% copy the input file generated by addHistINPfile
% write constituitive params to this copy
fprintf('Writing INP Parameters...');
for i = 1:length(testnames)
    % writeParamsINPfile(basefile, newfile, params)
    writeParamsINPfile( testnames{i}, [testnames{i} '-dum'], params );
end
fprintf(' Done!\n');

% run all requested jobs; load balance so only 5 are running simultaneously
msghandle = msgbox('Running Abaqus Jobs...');
runAbaqusJobs(strcat(testnames, '-dum'), 5);

% clean up msgbox
if ishandle(msghandle)
    close(msghandle);
end

% preallocate the error and error ratio
err      = ones(size(testnames));
errRatio = err;

% obtain the error for each test/simulation
fprintf('Extracting Errors from ODBs...');
for i = 1:length(testnames)

    % set job's .ODB name (also the name of the .INP file)
    fileID = [testnames{i} '-dum'];
    
    % set the name of the assembly-level reaction node set
    rxNodeSet = tests.(testnames{i}).rxNodeSet;
    
    % set the "real" test data
    if tests.(testnames{i}).symmetric
        % if the simulation is symmetric, divide displ by 2
        realdata = [tests.(testnames{i}).displ/2, tests.(testnames{i}).force];
    else
        % otherwise, use full displ
        realdata = [tests.(testnames{i}).displ, tests.(testnames{i}).force];
    end
    
    % calculate the residual error for this simulation
    [err(i), errRatio(i), forceDispl{i}] = ...
                 calcResidualError(fileID, realdata, errortype, rxNodeSet);
end
fprintf(' Done!\n');

% sum up the error for the PSO algorithm
combinedError = sum(errRatio);

%
% save parameter and error data to a .mat struct ~~~~~~~~~~~~~~~~~~~~~~~~~~
%
alldata = struct('params',params, 'newparams',newparams, ...
                 'combinedError',combinedError);

if exist('historyData.mat','file') == 2
    % if the .mat struct already exists... we want to append.
    load historyData historyData
    historyData{length(historyData)+1} = alldata;
else
    % otherwise, save as a new set of data.
    historyData{1} = alldata;
end

% save into .mat struct file
save historyData historyData

%
% if requested, perform fracture mechanics calcs ~~~~~~~~~~~~~~~~~~~~~~~~~~
%

fprintf('Extracting Fracture Mechanics Data, if requested...');
for i = 1:length(testnames)
    % only do it if requested...
    if tests.(testnames{i}).getIntPtdata
        IntPtNodeSet = tests.(testnames{i}).IntPtNodeSet;
        [~, PEEQ, Mises, Pressure, Inv3] = ...
                                   fetchOdbIntPtData(fileID, IntPtNodeSet);
    

        % triaxiality, PEEQ, and ... some other thing?
        % not sure what the cube of inv3/mises is. (something Chris wrote)
        PEEQfinal(i) =   PEEQ(end);
        Tfinal(i)    = - Pressure(end) / Mises(end); % triaxiality
        Xfinal(i)    =   ( Inv3(end) / Mises(end) )^3;
        
        % triaxiality history
        T = - Pressure(:) ./ Mises(:);
        T(isnan(T)) = 0; % if Mises is 0, triax is NaN
        
        % calculate SMCS and CVGM. See Kanvinde and Deierlein (2007)
        SMCSfinal(i) = PEEQfinal(i) / exp(-1.5*Tfinal(i));
        CVGMfinal(i) = sum( exp(1.5*abs(T)).*sign(T).*[0; diff(PEEQ)] ) ... 
                       / exp(-.47*sum([0; diff(PEEQ)].*(T<0)));
    end
end
fprintf(' Done!\n');

% assign output to varargout
varargout{1} = PEEQfinal;
varargout{2} = Tfinal;
varargout{3} = Xfinal;
varargout{4} = SMCSfinal;
varargout{5} = CVGMfinal;


%
% plot comparison of force-displacement ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%

figure(99)
splotwidth  = ceil(sqrt(length(testnames)));
splotheight = ceil(length(testnames)/splotwidth);

for i = 1:length(testnames)
    subplot(splotwidth, splotheight, i);
    
    % plot simulation data
    if tests.(testnames{i}).symmetric
        plot( forceDispl{i}(:,3)*2, forceDispl{i}(:,2),'g' )
    else
        plot( forceDispl{i}(:,3), forceDispl{i}(:,2),'g' )
    end
    hold on
    
    % plot real test data
    plot(tests.(testnames{i}).disp, tests.(testnames{i}).force);
    
    % give it a meaningful title
    title_ = sprintf(' %s\n errRatio = %s', ...
                     testnames{i}, num2str(errRatio(i)));
    title(title_);
end

% save to file
saveas(figure(99),'figure99');

end